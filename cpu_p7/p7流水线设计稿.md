# 基础定义
我们称M级为宏观级. F, D, E级的指令”未曾执行”, M级指令“正在执行”, W级指令“执行完毕”. 相当于把流水线CPU封装为一个单周期 CPU.
## 其中，编码ALUControl如下   
（考虑到无符号，均认为是逻辑右移）
| 编码 | 意义                                                         |
| ---- | ------------------------------------------------------------ |
| 0000 | 与                                                           |
| 0001 | 或                                                           |
| 0010 | 加                                                           |
| 0011 | 或非                                                         |
| 0100 | 左移16位并相或（注意这里16位是0x10而不是16，填的时候别填错了 |
| 0101 | 异或                                                         |
| 0110 | 减                                                           |
| 0111 | 小于置1(有符号)                                              |
| 1000 | 小于置1(无符号)                                              |


## 控制信号
| 控制信号  | 失效时作用（0）                 | 有效时作用(1)                  |
| --------- | ------------------------------- | ------------------------------ |
| RegDst    | 寄存器堆写入端地址来选择Rt字段  | 寄存器堆写入端地址选择 Rd字段  |
| MemtoReg  | 寄存器堆写入端数据来自ALU输出   | 寄存器堆写入端数据来自DM输出   |
| ALUSrc    | ALU输入端B选择寄存器堆输出R[rt] | ALU输入端B选择Signext输出      |
| PCSrc     | PC输入端选择 PC+4               | PC输入端选择beq指令的目的地址  |
| mem write | mem write                       | mem write                      |
| RegWrite  | 无                              | 把数据写入寄存器堆中对应寄存器 |
| Extop     | 有符号扩展                      | 无符号扩展                     |

新增：
|    output [1:0] byte_cho,
    output [2:0]load_op,
    output select,
    output start,
    output [3:0]mdu_ctrl//this can mean the instr is mdu
其中，byte——cho和loadop是用来选lb指令做什么的。
select 在e级生效，决定写进M级的ao的值是alu还是mdu的值
start是一旦是需要计算的指令就携带这个。
### 关于mdu乘法模块
要采取有限状态机形式来计算，内部设置各种时间寄存器和两个专门寄存器。
每一个乘除指令来的时候，仅仅考虑把信号带来，而不考虑带走什么结果。
直到计算结果完成，其他的和乘除模块有关的指令都要强行阻塞（不论是读还是如何都要直接暂停，引入unit控制）但是不能完全阻塞后面的值指令（如果不是mdu使用的话），然后插入延迟槽.
其中，打算让任何进来的东西一周期就计算结束，就可以输出，只不过busy直到最后计时才写回0
为了减少在mips主路的信号数量，决定使用多位信号来判断mdu的使能和行为选择.
其中直接用位拼接{}=*来计算相应值即可，考虑到每次只读出一个值，所以只考虑一个输出端口，分别供给hi和lo即可
| 指令   | 所用行为 | mdu_ctrl信号 | 所需时间             | 输出寄存器 |
| ------ | -------- | ------------ | -------------------- | ---------- |
| others | nothing  | 0000         | 0                    | /          |
| mfhi   | 读取     | 0001         | 0                    | hi         |
| mflo   | 读取     | 0010         | 0                    | lo         |
| mthi   | 写       | 0011         | 1                    | /          |
| mtlo   | 写       | 0100         | 1                    | /          |
| mult   | 计算     | 0101         | 5(包含写入，须暂停)  | /          |
| multu  | 计算     | 0110         | 5(包含写入，需暂停)  | /          |
| div    | 计算     | 0111         | 10(包含写入，需暂停) | /          |
| divu   | 计算     | 1111         | 10(包含写入，需暂停) | /          |

其中，读取是把lo或者hi的值存到某个标准寄存器里面，所以可能需要转发.
关于信号控制
clk,reset不解释。
4位mdu_ctrl (类似一个指令一样的东西，携带信息较多，直接传递来了)。
inA：写寄存器的值或者乘法除法的数字
inB：乘法除法数字
start：外来信号控制，当且仅当计算的时候有这个信号
busy:输出的东西，用来和unit判断是否来是否暂停
HIorLO:hi或者lo的输出。注意输出来讲，假如在计算的话，直接停止所有和这个mdu有关的东西就行了，这样的话不会产生冲突，所以什么时刻输出hi，原来的值还是什么其实无所谓。
​乘除模块行为约定如下：
```
    自 Start 信号有效后的第 1 个 clock 上升沿开始，乘除法部件开始执行运算，同时将 Busy 置位为 1。
    在运算结果保存到 HI 寄存器和 LO 寄存器后，Busy 位清除为 0。
    当 Busy 信号或 Start 信号为 1 时，mult, multu, div, divu, mfhi, mflo, mthi, mtlo 等乘除法相关的指令均被阻塞在 D 流水级。
    数据写入 HI 寄存器或 LO 寄存器，均只需 1 个时钟周期。
```

### 指令和信号

值得注意的是，在其中，有在lw，sw的情况下继续使用16位扩展的东西，然后多演出来一个RD2信号作为writedata写到存储单元里面。

其中，关于输出的三位ALU控制信号如图
新增控制信号 E_select
## 指令和对应alu信号
（如jr啥的信号就不管了，反正也不用计算。)
(仅考虑常规信号)
| 指令  | 信号四位 | regwrite | regdst | alusrc | Memreg  |extop  |
| ----- | -------- | -------- | ------ | ------ | ------ | ----- |
|mtc0   |0000      | 0        |0       |0       |0       |0      |
|mfc0   |0000      | 1        |0       |0       |0       |0      |
| add   | 0010     | 1        | 1      | 0      | 0      | 0     |
| sub   | 0110     | 1        | 1      | 0      | 0      | 0     |
| ori   | 0001     | 1        | 0      | 1      | 0      | 1     |
| lw    | 0010     | 1        | 0      | 1      | 1      | 0     |
| sw    | 0010     | 0        | 0      | 1      | 0      | 0     |
| beq   | 0000     | 0        | 0      | 0      | 0      | 0     |
| lui   | 0100     | 1        | 0      | 1      | 0      | 0     |
| and   | 0000     | 1        | 1      | 0      | 0      | 0     |
| or    | 0001     | 1        | 1      | 0      | 0      | 0     |
| slt   | 0111     | 1        | 1      | 0      | 0      | 0     |
| sltu  | 1000     | 1        | 1      | 0      | 0      | 0     |
| addi  | 0010     | 1        | 0      | 1      | 0      | 0     |
| andi  | 0000     | 1        | 0      | 1      | 0      | 1     |
| lb    | 0010     | 1        | 0      | 1      | 1      | 0     |
| lh    | 0010     | 1        | 0      | 1      | 1      | 0     |
| sb    | 0010     | 0        | 0      | 1      | 0      | 0     |
| sh    | 0010     | 0        | 0      | 1      | 0      | 0     |
| mult  | 0000     | 0        | 0      | 0      | 0      | 0     |
| multu | 0000     | 0        | 0      | 0      | 0      | 0     |
| div   | 0000     | 0        | 0      | 0      | 0      | 0     |
| divu  | 0000     | 0        | 0      | 0      | 0      | 0     |
| mfhi  | 0000     | 1        | 1      | 0      | 0      | 0     |
| mflo  | 0000     | 1        | 1      | 0      | 0      | 0     |
| mthi  | 0000     | 0        | 0      | 0      | 0      | 0     |
| mtlo  | 0000     | 0        | 0      | 0      | 0      | 0     |
| bne   | 0000     | 0        | 0      | 0      | 0      | 0     |

## 关于ctrl新的控制信号 
    output RI_sign,
    output Syscall_sign,
    output Eret_,
    output BD_F,
    type_ins,
    mtc0_d
    mfc0_
    其中type是用来在判断异常的时候看是什么类型的指令,00是其他指令，01是addaddisub，10是load，11是store类型指令。
    应该还需要进行关于c0寄存器的操作。
    还要多一个redRD传到M级写cp0
## 关于DM外移
直接影响就是需要新建一个BE来识别字节控制信号
然后取消memWrite的信号。
其实可以利用所有字节全是0写使能来？理解这个代码可以得到，假如字节使能不是全0，也就是要写才写，所以当字节使能为0的时候就选择0就完了。
```
    always @(posedge clk) begin
        if (reset) for (i = 0; i < 4096; i = i + 1) data[i] <= 0;
        else if (|m_data_byteen) begin
            data[fixed_addr >> 2] <= fixed_wdata;
            $display("%d@%h: *%h <= %h", $time, m_inst_addr, fixed_addr, fixed_wdata);
        end
    end
```
字节控制的情况有这样的 BE

| byte_cho | order | byte_en | behave         |
| -------- | ----- | ------- | -------------- |
| 00       | /     | 1111    | 整字写入       |
| 01       | 00    | 0011    | 写入后半段     |
| 01       | 10    | 1100    | 写入前半段     |
| 10       | 00    | 0001    | 写入第一个字节 |
| 10       | 01    | 0010    | 写入第二个字节 |
| 10       | 10    | 0100    | 写入第三个字节 |
| 10       | 11    | 1000    | 写入第四个字节 |

关于load的字节控制单元DBS
| op  | behave             |
| --- | ------------------ |
| 000 | 无扩展             |
| 001 | 无符号字节数据扩展 |
| 010 | 符号字节数据扩展   |
| 011 | 无符号半字数据扩展 |
| 100 | 符号半字数据扩展   |
## 关于异常传递
中断异常约束

    异常入口：《SMRL》的表 5.1 中定义了 MIPS 的异常入口，但考虑到简化设计以及与 MARS 保持一致，我们只支持 0x4180 一个入口地址，所有异常与中断都将从这里进入。
    嵌套中断异常：本实验不要求支持中断异常嵌套的情况。
    优先级：中断优先级高于异常优先级，即当有异常提交至 CP0 寄存器时，若有中断发生，则硬件应先响应中断，并重新执行受害指令及其后续指令；若没有中断发生，则处理异常。
这里把异常寄存器和流水线寄存器合并，每个异常部分的流水仅仅有一个输出，就是前面的异常码，考虑到*中断仅仅在cp0会出现，而中间不会出现*所以选择0为初始状态。
然后输入的话仅仅有本级流水的可能产生的异常信号和上一级流水输出的异常信号，假如上一级传进来的是0才考虑，不然直接不考虑。
在F级可能的是来自pc的    output AdEL_sign_pc，为4
在D级可能的是来自ctrl 的     output RI_sign,
    output Syscall_sign,
在E级有三个可能，分别是    output OV_sign,
    output AdEL_sign_alu,
    output AdES_sign_alu,
在M级有两个可能，不经过流水线寄存器了，在外面放吧
分别是    output AdES_sign_dm
和        output AdEL_sign_dm

## 关于CP0
寄存器 	编号 	功能
SR 	12 	配置异常的功能。
Cause 	13 	记录异常发生的原因和情况。
EPC 	14 	记录异常处理结束后需要返回的 PC
每个寄存器都是 32 位的，我们只需要其中的几位，列表如下：
|寄存器 |	功能域 |	位域 |	解释|
|-------|---------|---------|------------|
|SR（State Register）| 	IM（Interrupt Mask）| 	15:10 	|分别对应六个外部中断，相应位置 1 表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过 mtc0 这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。|
|SR（State Register）| 	EXL（Exception Level）| 	1 	|任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。|
|SR（State Register）| 	IE（Interrupt Enable）| 	0 	|全局中断使能，该位置 1 表示允许中断，置 0 表示禁止中断。|
|Cause 	|BD（Branch Delay）| 	31 |	当该位置 1 的时候，EPC 指向当前指令的前一条指令（一定为跳转），否则指向当前指令。|
|Cause 	|IP（Interrupt Pending）| 	15:10 |	为 6 位待决的中断位，分别对应 6 个外部中断，相应位置 1 表示有中断，置 0 表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。|
|Cause 	|ExcCode |	6:2 |	异常编码，记录当前发生的是什么异常。|
|EPC 	|- |	- |	记录异常处理结束后需要返回的 PC。|
一个很重要的点是，需要判断究竟是取地址的时候的溢出还是进行运算的时候的溢出。因为事实上这俩代码不一样。


| 异常与中断码 | 助记符与名称        | 指令与指令类型 | 描述                                                |
| ------------ | ------------------- | -------------- | --------------------------------------------------- |
| 0            | Int（外部中断）     | 所有指令       | 中断请求，来源于计时器与外部中断。                  |
| 4            | AdEL（取指异常）    | 所有指令       | PC 地址未字对齐。PC 地址超过 0x3000 ~ 0x6ffc。      |
|              | AdEL（取数异常）    | lw             | 取数地址未与 4 字节对齐。                           |
|              |                     | lh             | 取数地址未与 2 字节对齐。                           |
|              |                     | lh, lb         | 取 Timer 寄存器的值。                               |
|              |                     | load 型指令    | 计算地址时加法溢出。                                |
|              |                     | load 型指令    | 取数地址超出 DM、Timer0、Timer1、中断发生器的范围。 |
| 5            | AdES（存数异常）     |sw             | 存数地址未 4 字节对齐。                             |
|              |                     | sh             | 存数地址未 2 字节对齐。                             |
|              |                     | sh, sb         | 存 Timer 寄存器的值。                               |
|              |                     | store 型指令   | 计算地址加法溢出。                                  |
|              |                     | store 型指令   | 向计时器的 Count 寄存器存值。                       |
|              |                     | store 型指令   | 存数地址超出 DM、Timer0、Timer1、中断发生器的范围。 |
| 8            | Syscall（系统调用） | syscall        | 系统调用。                                          |
| 10           | RI（未知指令）      | -              | 未知的指令码。                                      |
| 12           | Ov（溢出异常）      | add, addi, sub | 算术溢出                                            |


|条目 	|地址或地址范围 	|备注
|数据存储器 	|0x0000_0000∼0x0000_2FFF0x0000_0000∼0x0000_2FFF |	
|指令存储器 	|0x0000_3000∼0x0000_6FFF0x0000_3000∼0x0000_6FFF |	
|PC 初始值 	|0x0000_30000x0000_3000 	|
|异常处理程序入口地址 	|0x0000_41800x0000_4180 	|
|计时器 0 寄存器地址 	|0x0000_7F00∼0x0000_7F0B0x0000_7F00∼0x0000_7F0B |	计时器 0 的 3 个寄存器|
|计时器 1 寄存器地址 	|0x0000_7F10∼0x0000_7F1B0x0000_7F10∼0x0000_7F1B |	计时器 1 的 3 个寄存器
|中断发生器响应地址 	|0x0000_7F20∼0x0000_7F230x0000_7F20∼0x0000_7F23 |	
本设计中外设与数据存储器均连入M级, 需要使用系统桥进行线路选择. 系统桥一端直接接受CPU中M级传来的地址, 写使能, 写数据, 并向CPU发送读出的数据; 另一端向外设与数据存储器发送地址与写使能, 写数据, 并从外设与数据存储器接受读出的数据
# 关键考虑
## 异常产生的位置和cp0
1，pc段的指令未冲齐，产生的是AdElsign_pc,或者超界
2，D段的译码没有那个指令，还有D段的syscall
3，alu段的溢出
4.M段的地址异常
但是一条指令仅仅把最先产生的异常传进来
## 进入异常处理以及eret复位
1.在cp0发现异常的时候，要清空F（pc)DEM寄存器，然后让npc成那个固定的数字
2.当异常处理的时候发现eret的时候，让PC的输出直接变成EPC的值就行了。
3.当中断的时候（内部异常的话不会在nop的时候出现），假设中断发生的时候这个nop刚好到M级，
那么这个nop存的pc就是0，根本没法回去，所以看到是在阻塞的时候就应该nop存成一个之后的指令（前级，也就是E级存D级，因为当nop到M级的时候，前面的W级指令已经在宏观pc上执行完了。
## 延迟槽校验
如何判断这个指令是不是在延迟槽？
需要在CTRL（这个是D寄存器的结果端的东西）在D的输入端输进来一个BD_F,代表这时候D的指令是一个跳转指令，这样下一个指令存进来的话就是自动把这个BD_F带进来了
## 关于跳转到异常处理指令时候的pc的变化
理论上，跳转到异常处理指令的时候清空的F寄存器，是清空成3000了还是？
至少已知的是NPC会强制换乘4180，但是问题是pc应该是多少？假如是3000的话是不是会导致多做一遍3000这个指令？
首先绝对不能是3000，这样显然是多做了一遍，其次绝对不能是0000，这样会出现地址异常，异常套异常就寄了
所以其实pc的清空没必要单独算，npc立即响应成4180，之后（req信号仍在那里抵着）下一个进来pc的就是4180了。
也就是说当req生效的时候，下一周期D并不接受pc的值，而是指令地址变成4180然后（这个4180仅仅是象征的）指令是4180
所以这时候（指req生效的那个周期）pc是啥没意义，但是绝对要保证req生效后的下一个周期立即让pc成4180；
用时序逻辑思考指令进来的先后问题。当指令正常的进行这，cp0检测发现了中断，这时候cp0通过组合逻辑输出 的req是1，但是这时候所有寄存器里面的东西其实是不变的
下一个周期到来，req抵到了入口，所以其他东西也按照req来
*在发生异常时，我们需要立即跳到异常响应代码，并且清空流水线内还没有执行完的指令，一定要在“立即上”，因为假如不是立即的话，D会立即进来一个nop，奇怪的nop，他的地址都是错误的（虽然指令确实是nop），所以要立即让所有寄存器的pc都设计成0x4180，然后pc也立即变成0x4180*
## cp0的处理问题
用宏来定义各个寄存器的具体段
```
`define IM SR[15:10]//分别对应若干外设中断，可以通过设置0,1来屏蔽中断类型
`define EXL SR[1]//发生异常时置位，强制进入异常处理状态
`define IE SR[0]//全局中断使能，1时允许中断，0时不行
`define BD Cause[31]//是否是延迟槽中的指令
`define IP Cause[15:10]//6个位，每个位为1代表当前有中断。
`define ExcCode Cause[6:2]//异常的类型
```
然后内部异常和外部中断都是跳转到相同的地址，所以理论上二者是可以合到一起考虑Req的
然后关于改变，除了reset，剩下的应该是不清空Cp0寄存器的
Cp0寄存器应该如何“覆写”？
显然在处理这个异常的时候是不应该去覆写的，仅仅当处理结束之后才覆写
需要
```
退出异常的条件是识别到了 eret，我们直接把 EXLClr 接上 M_eret 就好。，所以也是要传这个东西的.
```
然后，当检测到异常的时候，应当用组合逻辑去写req方便其他的部件下一周期立即跳转
所以应该用Wire assign而不是reg
## 关于新指令的转发和阻塞
用cp0的指令只有那个新的俩，就是mtc0和mfc0
考虑mtc0，它要写入的只有cp0的寄存器，不需要它作为结果转发出去，但是它是在M级，然后以前的指令（W）可能存在写转发，所以要在入口处转发rt的值，就和DM入口处的转发一样，加一个Tuse特判就好了
考虑mfc0它是一个类似lw类型的指令，它的值仅在W级才得到（和lw一样），然后需要转发和阻塞，（rt是转发的对象），假如是因为mf要写某个寄存器而没能在使用前生成，就需要阻塞！！
表格如下
指令	Tuse		Tnew			regwrite	
	rs	rt	E	M	W		
mfc0	\	\	2	1	0	1	
mtc0	\	2	0	0	0	0	
## 关于系统桥


CPU 中 store 类指令需要储存的数据经过 BE 处理后会通过 m_data_addr, m_data_byteen, m_data_wdata 三个信号输出到桥中，桥会根据写使能 m_data_byteen 和地址 m_data_addr 来判断到底写的是内存还是外设，然后给出正确的写使能

load 类指令则是全部把地址传递给每个外设和 DM 中，然后桥根据地址选择从应该反馈给 CPU 从哪里读出来的数据，然后 DE 在处理读出的数据，反馈正确的结果




# 思考题
## 1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？
控制鼠标的过程，不是在和CPU交互，而是在和操作系统交互，由操作系统告诉CPU该计算什么。关于鼠标和操作系统的交互，在开机之后鼠标就有一个坐标，而光学鼠标的精度单位DPI(每英寸在屏幕上移动多少个点)不需要给予什么过多的信息，鼠标知道了自己向上移动了一英寸，只需要告诉系统:我向上移动了2500个点。然后操作系统得到新的坐标反馈到图形界面也就是显卡(显示器)，让这个界面反馈给你。
中断扫描工作方式是当键盘上有键闭合时产生中断请求，CPU响应中断请求后，转去执行中断服务程序，在中断服务程序中判别键盘上闭合键的键号，并作相应的处理。 

鼠标和键盘产生中断信号，进入中断处理区的对应位置，将输入信号从鼠标和键盘中读入寄存器
## 2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）
应该是可以的，，然后新增加一个默认寄存器（在cp0）里，存这个地址，默认为4180，然后可以用mtc0修改，然后从cp0里伸出来一根线连到NPC里和pc里代替
比如
```
assign newPc=(Req==1'b1)?to_unexpect_reg:
             (Eret_D==1'b1)?(EPC+4):
             (Jump==1'b1)?out2:out1;
```
问题在可能有指令错误修改这个地方的寄存器，然后导致无法处理异常（始终跳转错误）
或者在写这个指令的时候出现异常。
## 3、为何与外设通信需要 Bridge？
因为对于很多种不同的外设，假如在cpu里针对每一个外设去判断过于复杂，必须要一个统一的接口来完成，这样类似一种虚存的效果，让对存储的处理非常容易。
## 4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。
同：都是在倒计时为0的时候输出一个中断信号
异，一个是定时中断，设定一次然后仅仅发生一次，下次需要在设定enable才能继续进行。另一个则是周期循环中断，没经过一段时间都发生一次中断，
图片见附件。
## 5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？
这样的话首先不知道是不是延迟槽指令，其次不知道其地址，根本么办法调回去重新执行
保留当前地址和是否是延迟槽指令。
## 6、为什么 jalr 指令为什么不能写成 jalr $31, $31？
不考虑异常处理的时候是可以的。
但是考虑的时候就不行了，原因在于假如jalr后的两个寄存器相同，那么若jalr后的延迟槽指令出现异常，VPC写入pc-4，也就是jalr，对于之前的jal，jr等指令没问题是因为他们多次重复执行不影响结果，但是jalr已经更改了这个寄存器的数值，第二次执行的时候回到错误的地方。







